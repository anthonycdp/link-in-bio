# Tech Stack and Dependencies Guidelines

## Core Technologies

### Frontend Stack
- **React 18+**: Modern React with hooks and concurrent features
- **TypeScript**: Strict type checking and modern ES features
- **Vite**: Fast build tool and development server
- **Tailwind CSS**: Utility-first CSS framework

### UI Component Library
- **shadcn/ui**: High-quality, customizable React components
- **Radix UI**: Headless UI primitives for accessibility
- **Lucide React**: Icon library for consistent iconography

### Development Tools
- **Vitest**: Fast unit testing framework
- **Testing Library**: React component testing utilities
- **ESLint**: Code linting and style enforcement
- **Prettier**: Code formatting

## Package Management

### Installation Guidelines
```bash
# Install production dependencies
npm install <package-name>

# Install development dependencies
npm install -D <package-name>

# Always use exact versions for critical dependencies
npm install --save-exact <package-name>
```

### Version Management
- Pin major versions for stability
- Use semantic versioning principles
- Regular dependency updates with testing
- Monitor security vulnerabilities

## Dependency Categories

### Core Dependencies (Never Remove)
```json
{
  "react": "^18.0.0",
  "react-dom": "^18.0.0",
  "typescript": "^5.0.0",
  "vite": "^5.0.0"
}
```

### UI and Styling
```json
{
  "tailwindcss": "^3.4.0",
  "@tailwindcss/typography": "^0.5.0",
  "clsx": "^2.0.0",
  "tailwind-merge": "^2.0.0"
}
```

### Component Libraries
```json
{
  "@radix-ui/react-*": "^1.0.0",
  "lucide-react": "^0.400.0",
  "class-variance-authority": "^0.7.0"
}
```

### Development Dependencies
```json
{
  "@types/react": "^18.0.0",
  "@types/react-dom": "^18.0.0",
  "@vitejs/plugin-react": "^4.0.0",
  "vitest": "^1.0.0",
  "@testing-library/react": "^14.0.0"
}
```

## Adding New Dependencies

### Before Adding Dependencies
1. **Evaluate Necessity**
   - Can existing tools solve the problem?
   - Is the functionality critical?
   - What's the bundle size impact?

2. **Research Package Quality**
   - Active maintenance and updates
   - Good documentation and community support
   - TypeScript support
   - Security track record

3. **Consider Alternatives**
   - Compare similar packages
   - Evaluate trade-offs
   - Check compatibility with existing stack

### Installation Process
```bash
# 1. Research and evaluate
npm info <package-name>

# 2. Install with appropriate flag
npm install <package-name>
# or for dev dependencies
npm install -D <package-name>

# 3. Update TypeScript types if needed
npm install -D @types/<package-name>

# 4. Test integration
npm run test
npm run build
```

## Package Configuration

### TypeScript Configuration
```json
{
  "compilerOptions": {
    "strict": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  }
}
```

### Vite Configuration
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
```

## Build and Bundling

### Production Builds
- Optimize bundle size with tree shaking
- Use code splitting for large applications
- Implement proper caching strategies
- Monitor bundle analysis

### Build Commands
```bash
# Development
npm run dev

# Production build
npm run build

# Preview production build
npm run preview

# Run tests
npm run test
```

## Security Considerations

### Dependency Security
- Regular security audits: `npm audit`
- Use `npm audit fix` for automatic fixes
- Monitor for security advisories
- Keep dependencies updated

### Package Verification
- Verify package authenticity
- Check for suspicious dependencies
- Use lock files for reproducible builds
- Review dependency changes in PRs

## Performance Optimization

### Bundle Size Management
- Use dynamic imports for code splitting
- Analyze bundle composition
- Remove unused dependencies
- Optimize import statements

### Runtime Performance
- Lazy load components when appropriate
- Use React.memo for expensive components
- Implement proper caching strategies
- Monitor Core Web Vitals

## Migration Guidelines

### Updating Dependencies
1. **Plan Updates**
   - Read changelogs and breaking changes
   - Update dependencies incrementally
   - Test thoroughly after each update

2. **Testing Strategy**
   - Run full test suite
   - Test critical user flows
   - Check for TypeScript errors
   - Validate build process

3. **Rollback Plan**
   - Keep previous package-lock.json
   - Document changes made
   - Have rollback procedure ready

## Troubleshooting

### Common Issues
- **Module Resolution**: Check path aliases and imports
- **TypeScript Errors**: Update type definitions
- **Build Failures**: Check for breaking changes in dependencies
- **Runtime Errors**: Verify component API changes

### Debug Commands
```bash
# Clear node_modules and reinstall
rm -rf node_modules package-lock.json
npm install

# Check for dependency conflicts
npm ls

# Audit security issues
npm audit

# Update outdated packages
npm outdated
```