# UI Components Guidelines

## Component Architecture

### shadcn/ui Integration
- Use shadcn/ui as the foundation for UI components
- Customize components through CSS variables and Tailwind
- Maintain consistent design tokens across components
- Follow shadcn/ui patterns for component structure

### Component Categories

#### Base Components (shadcn/ui)
```
components/ui/
├── button.tsx          # Primary action elements
├── input.tsx           # Form input fields
├── card.tsx            # Content containers
├── dialog.tsx          # Modal dialogs
├── alert.tsx           # Status messages
└── ...                 # Other base components
```

#### Composite Components
```
components/
├── Header.tsx          # Application header
├── ClinicSection.tsx   # Feature-specific sections
├── WhatsAppIcon.tsx    # Custom icons
└── ...                 # Other composite components
```

## Component Design Principles

### Composition Over Configuration
- Build complex components from simpler ones
- Use children prop for flexible content
- Implement compound components for related functionality

```typescript
// Good: Composition pattern
<Card>
  <CardHeader>
    <CardTitle>Title</CardTitle>
  </CardHeader>
  <CardContent>
    Content here
  </CardContent>
</Card>

// Avoid: Over-configuration
<Card 
  title="Title" 
  content="Content" 
  showHeader={true}
  headerStyle="default"
/>
```

### Prop Interface Design
- Use discriminated unions for variant props
- Provide sensible defaults
- Keep required props minimal
- Use TypeScript for prop validation

```typescript
interface ButtonProps {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link'
  size?: 'default' | 'sm' | 'lg' | 'icon'
  children: React.ReactNode
  className?: string
  disabled?: boolean
  onClick?: () => void
}
```

## Styling Guidelines

### CSS Variables for Theming
```css
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;
  --muted: 210 40% 96%;
  --muted-foreground: 215.4 16.3% 46.9%;
}
```

### Component Styling Patterns
```typescript
// Using cn utility for conditional classes
import { cn } from '@/lib/utils'

const Button = ({ variant, size, className, ...props }) => {
  return (
    <button
      className={cn(
        // Base styles
        "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
        "disabled:pointer-events-none disabled:opacity-50",
        // Variant styles
        {
          "bg-primary text-primary-foreground hover:bg-primary/90": variant === "default",
          "bg-destructive text-destructive-foreground hover:bg-destructive/90": variant === "destructive",
          "border border-input hover:bg-accent hover:text-accent-foreground": variant === "outline",
        },
        // Size styles
        {
          "h-10 px-4 py-2": size === "default",
          "h-9 rounded-md px-3": size === "sm",
          "h-11 rounded-md px-8": size === "lg",
        },
        className
      )}
      {...props}
    />
  )
}
```

## Accessibility Standards

### ARIA Implementation
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation support
- Provide screen reader support

```typescript
const Button = ({ children, ...props }) => {
  return (
    <button
      role="button"
      aria-disabled={props.disabled}
      tabIndex={props.disabled ? -1 : 0}
      {...props}
    >
      {children}
    </button>
  )
}
```

### Focus Management
```typescript
const Dialog = ({ isOpen, onClose, children }) => {
  const dialogRef = useRef<HTMLDivElement>(null)
  
  useEffect(() => {
    if (isOpen) {
      dialogRef.current?.focus()
    }
  }, [isOpen])
  
  return (
    <div
      ref={dialogRef}
      role="dialog"
      aria-modal="true"
      tabIndex={-1}
      onKeyDown={(e) => {
        if (e.key === 'Escape') {
          onClose()
        }
      }}
    >
      {children}
    </div>
  )
}
```

## Component Patterns

### Compound Components
```typescript
// Card compound component
const Card = ({ children, className, ...props }) => (
  <div className={cn("rounded-lg border bg-card", className)} {...props}>
    {children}
  </div>
)

const CardHeader = ({ children, className, ...props }) => (
  <div className={cn("flex flex-col space-y-1.5 p-6", className)} {...props}>
    {children}
  </div>
)

const CardTitle = ({ children, className, ...props }) => (
  <h3 className={cn("text-2xl font-semibold leading-none", className)} {...props}>
    {children}
  </h3>
)

// Export as compound component
Card.Header = CardHeader
Card.Title = CardTitle
Card.Content = CardContent
```

### Polymorphic Components
```typescript
interface PolymorphicProps<T extends React.ElementType> {
  as?: T
  children: React.ReactNode
}

type Props<T extends React.ElementType> = PolymorphicProps<T> & 
  Omit<React.ComponentPropsWithoutRef<T>, keyof PolymorphicProps<T>>

function Text<T extends React.ElementType = 'span'>({ 
  as, 
  children, 
  ...props 
}: Props<T>) {
  const Component = as || 'span'
  return <Component {...props}>{children}</Component>
}

// Usage
<Text as="h1">Heading</Text>
<Text as="p">Paragraph</Text>
```

## State Management

### Local State
- Use useState for simple component state
- Use useReducer for complex state logic
- Implement proper state updates

```typescript
const Counter = () => {
  const [count, setCount] = useState(0)
  
  const increment = useCallback(() => {
    setCount(prev => prev + 1)
  }, [])
  
  return (
    <div>
      <span>{count}</span>
      <Button onClick={increment}>+</Button>
    </div>
  )
}
```

### Form State
```typescript
const ContactForm = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  })
  
  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
  }
  
  return (
    <form>
      <Input 
        value={formData.name}
        onChange={(e) => handleChange('name', e.target.value)}
      />
      {/* Other form fields */}
    </form>
  )
}
```

## Testing Components

### Component Testing Strategy
- Test user interactions, not implementation
- Use React Testing Library
- Focus on accessibility and behavior
- Mock external dependencies

```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import { Button } from './Button'

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })
  
  it('calls onClick when clicked', () => {
    const handleClick = vi.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    
    fireEvent.click(screen.getByText('Click me'))
    expect(handleClick).toHaveBeenCalledOnce()
  })
  
  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>)
    expect(screen.getByText('Click me')).toBeDisabled()
  })
})
```

### Visual Testing
- Test responsive design
- Verify color contrast
- Check component variants
- Validate dark/light themes

## Performance Optimization

### Memoization
```typescript
// Memoize expensive components
const ExpensiveComponent = React.memo(({ data }) => {
  const processedData = useMemo(() => {
    return processData(data)
  }, [data])
  
  return <div>{processedData}</div>
})

// Memoize callbacks
const ParentComponent = () => {
  const handleClick = useCallback(() => {
    // Handle click
  }, [])
  
  return <ChildComponent onClick={handleClick} />
}
```

### Lazy Loading
```typescript
// Lazy load heavy components
const HeavyComponent = lazy(() => import('./HeavyComponent'))

const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <HeavyComponent />
  </Suspense>
)
```

## Documentation

### Component Documentation
- Document props and their types
- Provide usage examples
- Include accessibility notes
- Show different variants

```typescript
/**
 * Button component for primary actions
 * 
 * @example
 * <Button variant="primary" onClick={handleClick}>
 *   Submit
 * </Button>
 * 
 * @accessibility
 * - Supports keyboard navigation
 * - Screen reader compatible
 * - Focus visible indicators
 */
interface ButtonProps {
  /** Button content */
  children: React.ReactNode
  /** Visual variant of the button */
  variant?: 'default' | 'destructive' | 'outline'
  /** Size of the button */
  size?: 'default' | 'sm' | 'lg'
  /** Click handler */
  onClick?: () => void
  /** Whether button is disabled */
  disabled?: boolean
}
```

## Best Practices

### Do's
- Keep components focused and single-purpose
- Use TypeScript for prop validation
- Implement proper accessibility
- Follow shadcn/ui patterns
- Write comprehensive tests

### Don'ts
- Don't create overly complex components
- Avoid inline styles, use Tailwind classes
- Don't ignore accessibility requirements
- Don't skip testing interactive behavior
- Avoid tight coupling between components